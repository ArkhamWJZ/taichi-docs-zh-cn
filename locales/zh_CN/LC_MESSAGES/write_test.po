# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Taichi Developers
# This file is distributed under the same license as the taichi package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: taichi 0.6.24\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-02 22:06+0800\n"
"PO-Revision-Date: 2020-10-26 23:58+0800\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"X-Generator: Poedit 2.3\n"

#: ../../write_test.rst:2
msgid "Workflow for writing a Python test"
msgstr "编写Python测试的工作流程"

#: ../../write_test.rst:4
msgid "Normally we write functional tests in Python."
msgstr "通常，我们用Python编写功能测试。"

#: ../../write_test.rst:6
msgid ""
"We use `pytest <https://github.com/pytest-dev/pytest>`_ for our Python test "
"infrastructure."
msgstr ""
"我们将 `pytest <https://github.com/pytest-dev/pytest>`_ 作为 Python 测试的基础"
"架构。"

#: ../../write_test.rst:7
msgid "Python tests should be added to ``tests/python/test_xxx.py``."
msgstr "Python测试应添加到 ``tests/python/test_xxx.py`` 中。"

#: ../../write_test.rst:9
msgid ""
"For example, you've just added a utility function ``ti.log10``. Now you want to "
"write a **test**, to test if it functions properly."
msgstr ""
"例如，你刚刚添加了一个功能函数 ``ti.log10`` 。 现在想要编写一个 **test** ，以测"
"试其是否正常运行。"

#: ../../write_test.rst:13
msgid "Adding a new test case"
msgstr "添加一个新的测试用例"

#: ../../write_test.rst:15
msgid ""
"Look into ``tests/python``, see if there's already a file suit for your test. "
"If not, feel free to create a new file for it :) So in this case let's create a "
"new file ``tests/python/test_logarithm.py`` for simplicity."
msgstr ""
"在 ``tests/python`` 中查看是否已经有适合你测试的文件。 如果没有，请随时为它创建"
"一个新文件 :) 如此，按照上述示例让我们创建一个新文件 ``tests/"
"python/test_logarithm.py`` 即可。"

#: ../../write_test.rst:19
msgid ""
"Add a function, the function name **must** be started with ``test_`` so that "
"``pytest`` could find it. e.g:"
msgstr ""
"添加一个函数，函数名称 **必须** 以 ``test_`` 开头，以便 ``pytest`` 可以找到它。 "
"例如："

#: ../../write_test.rst:21
msgid ""
"import taichi as ti\n"
"\n"
"def test_log10():\n"
"    pass"
msgstr ""
"import taichi as ti\n"
"\n"
"def test_log10():\n"
"    pass"

#: ../../write_test.rst:28
msgid ""
"Add some simple code make use of our ``ti.log10`` to make sure it works well. "
"Hint: You may pass/return values to/from Taichi-scope using 0-D tensors, i.e. "
"``r[None]``."
msgstr ""
"利用我们的 ``ti.log10`` 添加一些简单代码，以确保其正常工作。 提示：你可以使用 "
"0-D 张量（即 ``r[None]`` ）向 Taichi-scop 传递值或从中返回。"

#: ../../write_test.rst:31
msgid ""
"import taichi as ti\n"
"\n"
"def test_log10():\n"
"    ti.init(arch=ti.cpu)\n"
"\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == 2"
msgstr ""
"import taichi as ti\n"
"\n"
"def test_log10():\n"
"    ti.init(arch=ti.cpu)\n"
"\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == 2"

#: ../../write_test.rst:48
msgid ""
"Execute ``ti test logarithm``, and the functions starting with ``test_`` in "
"``tests/python/test_logarithm.py`` will be executed."
msgstr ""
"执行 ``ti test logarithm`` ，随后 ``tests/python/test_logarithm.py`` 中以 "
"``test_`` 开头的函数就会被运行。"

#: ../../write_test.rst:51
msgid "Testing against multiple backends"
msgstr "针对多个后端进行测试"

#: ../../write_test.rst:53
msgid ""
"The above method is not good enough, for example, ``ti.init(arch=ti.cpu)``, "
"means that it will only test on the CPU backend. So do we have to write many "
"tests ``test_log10_cpu``, ``test_log10_cuda``, ... with only the first line "
"different? No worries, we provide a useful decorator ``@ti.test``:"
msgstr ""
"上面的方法还不够好，例如， ``ti.init(arch=ti.cpu)`` ，意味着它将仅在CPU后端进行"
"测试。 那么，我们是否必须编写繁多的测试文件，诸如： ``test_log10_cpu`` ，"
"``test_log10_cuda`` ，...，而它们只有第一行的代码是不同的？ 不用担心，我们提供了一个有用的装饰"
"器 ``@ti.test`` ："

#: ../../write_test.rst:57
msgid ""
"import taichi as ti\n"
"\n"
"# will test against both CPU and CUDA backends\n"
"@ti.test(ti.cpu, ti.cuda)\n"
"def test_log10():\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == 2"
msgstr ""
"import taichi as ti\n"
"\n"
"# 将同时测试CPU和CUDA后端\n"
"@ti.test(ti.cpu, ti.cuda)\n"
"def test_log10():\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == 2"

#: ../../write_test.rst:74
msgid ""
"And you may test against **all backends** by simply not specifying the argument:"
msgstr "您可以通过不指定参数来针对 **所有后端** 进行测试："

#: ../../write_test.rst:76
msgid ""
"import taichi as ti\n"
"\n"
"# will test against all backends available on your end\n"
"@ti.test()\n"
"def test_log10():\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == 2"
msgstr ""
"import taichi as ti\n"
"\n"
"# 将针对你这一端可用的所有后端进行测试\n"
"@ti.test()\n"
"def test_log10():\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == 2"

#: ../../write_test.rst:93
msgid "Cool! Right? But that's still not good enough."
msgstr "很酷不是吗？ 但是，这还不够好。"

#: ../../write_test.rst:96
msgid "Using ``ti.approx`` for comparison with tolerance"
msgstr "使用 ``ti.approx`` 与公差进行比较"

#: ../../write_test.rst:98
msgid ""
"Sometimes the math percison could be poor on some backends like OpenGL, e.g. "
"``ti.log10(100)`` may return ``2.001`` or ``1.999`` in this case."
msgstr ""
"有时，在某些后端（例如OpenGL）上，数学精准度可能很差。 在这种情况下， ``ti."
"log10(100)`` 可能会返回 ``2.001`` 或 ``1.999`` 。"

#: ../../write_test.rst:101
msgid ""
"To cope with this behavior, we provide ``ti.approx`` which can tolerate such "
"errors on different backends, for example ``2.001 == ti.approx(2)`` will return "
"``True`` on the OpenGL backend."
msgstr ""
"为了解决此问题，我们提供了 ``ti.approx`` ，它可以在不同的后端上容忍此类错误，例"
"如，``2.001 == ti.approx(2)`` 将在OpenGL后端上返回 ``True`` 。"

#: ../../write_test.rst:104
msgid ""
"import taichi as ti\n"
"\n"
"# will test against all backends available on your end\n"
"@ti.test()\n"
"def test_log10():\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == ti.approx(2)"
msgstr ""
"import taichi as ti\n"
"\n"
"# 将针对你这一端可用的所有后端进行测试\n"
"@ti.test()\n"
"def test_log10():\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == ti.approx(2)"

#: ../../write_test.rst:123
msgid ""
"Simply using ``pytest.approx`` won't work well here, since it's tolerance won't "
"vary among different Taichi backends. It'll be likely to fail on the OpenGL "
"backend."
msgstr ""
"直接使用 ``pytest.approx`` 在这里表现不是很好，因为它的公差在不同的 Taichi 后"
"端之间不会有所不同。 而它在OpenGL后端上可能会失败。"

#: ../../write_test.rst:126
msgid ""
"``ti.approx`` also do treatments on boolean types, e.g.: ``2 == ti."
"approx(True)``."
msgstr "``ti.approx`` 也会对布尔类型进行处理，例如： ``2 == ti.approx(True)`` 。"

#: ../../write_test.rst:128
msgid "Great on improving stability! But the test is still not good enough, yet."
msgstr "极大地提高了稳定性！ 但是测试还不够好。"

#: ../../write_test.rst:131
msgid "Parametrize test inputs"
msgstr "参数化测试输入"

#: ../../write_test.rst:133
msgid ""
"For example, ``r[None] = 100``, means that it will only test the case of ``ti."
"log10(100)``. What if ``ti.log10(10)``? ``ti.log10(1)``?"
msgstr ""
"例如，``r[None] = 100`` ，意味着它将仅仅测试 ``ti.log10(100)`` 的情况。 那如果 "
"``ti.log10(10)`` 怎么办？ ``ti.log10(1)`` 呢？"

#: ../../write_test.rst:136
msgid ""
"We may test against different input values using the ``@pytest.mark."
"parametrize`` decorator:"
msgstr ""
"我们可以使用 ``@pytest.mark.parametrize`` 装饰器针对不同的输入值进行测试："

#: ../../write_test.rst:138
msgid ""
"import taichi as ti\n"
"import pytest\n"
"import math\n"
"\n"
"@pytest.mark.parametrize('x', [1, 10, 100])\n"
"@ti.test()\n"
"def test_log10(x):\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = x\n"
"    foo()\n"
"    assert r[None] == math.log10(x)"
msgstr ""
"import taichi as ti\n"
"import pytest\n"
"import math\n"
"\n"
"@pytest.mark.parametrize('x', [1, 10, 100])\n"
"@ti.test()\n"
"def test_log10(x):\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = x\n"
"    foo()\n"
"    assert r[None] == math.log10(x)"

#: ../../write_test.rst:157
msgid "Use a comma-separated list for multiple input values:"
msgstr "将逗号分隔的表用于多个输入值："

#: ../../write_test.rst:159
msgid ""
"import taichi as ti\n"
"import pytest\n"
"import math\n"
"\n"
"@pytest.mark.parametrize('x,y', [(1, 2), (1, 3), (2, 1)])\n"
"@ti.test()\n"
"def test_atan2(x, y):\n"
"    r = ti.var(ti.f32, ())\n"
"    s = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.atan2(r[None])\n"
"\n"
"    r[None] = x\n"
"    s[None] = y\n"
"    foo()\n"
"    assert r[None] == math.atan2(x, y)"
msgstr ""
"import taichi as ti\n"
"import pytest\n"
"import math\n"
"\n"
"@pytest.mark.parametrize('x,y', [(1, 2), (1, 3), (2, 1)])\n"
"@ti.test()\n"
"def test_atan2(x, y):\n"
"    r = ti.var(ti.f32, ())\n"
"    s = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.atan2(r[None])\n"
"\n"
"    r[None] = x\n"
"    s[None] = y\n"
"    foo()\n"
"    assert r[None] == math.atan2(x, y)"

#: ../../write_test.rst:180
msgid ""
"Use two separate ``parametrize`` to test **all combinations** of input "
"arguments:"
msgstr "使用两个独立的 ``参数'`` 来测试输入参数的 **所有组合**："

#: ../../write_test.rst:182
msgid ""
"import taichi as ti\n"
"import pytest\n"
"import math\n"
"\n"
"@pytest.mark.parametrize('x', [1, 2])\n"
"@pytest.mark.parametrize('y', [1, 2])\n"
"# same as:  .parametrize('x,y', [(1, 1), (1, 2), (2, 1), (2, 2)])\n"
"@ti.test()\n"
"def test_atan2(x, y):\n"
"    r = ti.var(ti.f32, ())\n"
"    s = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.atan2(r[None])\n"
"\n"
"    r[None] = x\n"
"    s[None] = y\n"
"    foo()\n"
"    assert r[None] == math.atan2(x, y)"
msgstr ""
"import taichi as ti\n"
"import pytest\n"
"import math\n"
"\n"
"@pytest.mark.parametrize('x', [1, 2])\n"
"@pytest.mark.parametrize('y', [1, 2])\n"
"# 等同于：  .parametrize('x,y', [(1, 1), (1, 2), (2, 1), (2, 2)])\n"
"@ti.test()\n"
"def test_atan2(x, y):\n"
"    r = ti.var(ti.f32, ())\n"
"    s = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.atan2(r[None])\n"
"\n"
"    r[None] = x\n"
"    s[None] = y\n"
"    foo()\n"
"    assert r[None] == math.atan2(x, y)"

#: ../../write_test.rst:206
msgid "Specifying ``ti.init`` configurations"
msgstr "指定 ``ti.init`` 配置"

#: ../../write_test.rst:208
msgid "You may specify keyword arguments to ``ti.init()`` in ``ti.test()``, e.g.:"
msgstr "您可以在 ``ti.test()`` 中为 ``ti.init()`` 指定关键字参数，例如："

#: ../../write_test.rst:210
msgid ""
"@ti.test(ti.cpu, debug=True, log_level=ti.TRACE)\n"
"def test_debugging_utils():\n"
"    # ... (some tests have to be done in debug mode)"
msgstr ""
"@ti.test(ti.cpu, debug=True, log_level=ti.TRACE)\n"
"def test_debugging_utils():\n"
"    # ...（某些测试必须在调试模式下完成）"

#: ../../write_test.rst:216
msgid "is the same as:"
msgstr "等同于："

#: ../../write_test.rst:218
msgid ""
"def test_debugging_utils():\n"
"    ti.init(arch=ti.cpu, debug=True, log_level=ti.TRACE)\n"
"    # ... (some tests have to be done in debug mode)"
msgstr ""
"def test_debugging_utils():\n"
"    ti.init(arch=ti.cpu, debug=True, log_level=ti.TRACE)\n"
"    # ...（某些测试必须在调试模式下完成）"

#: ../../write_test.rst:225
msgid "Exclude some backends from test"
msgstr "在测试时排除一些后端"

#: ../../write_test.rst:227
msgid ""
"Sometimes some backends are not capable of specific tests, we have to exclude "
"them from test:"
msgstr "有时，一些后端无法执行特定的测试，我们必须将它们从测试中排除："

#: ../../write_test.rst:229
msgid ""
"# Run this test on all backends except for OpenGL\n"
"@ti.test(excludes=[ti.opengl])\n"
"def test_sparse_tensor():\n"
"    # ... (some tests that requires sparse feature which is not supported by "
"OpenGL)"
msgstr ""
"# 在除OpenGL之外的所有后端上运行此测试 \n"
"@ti.test(excludes=[ti.opengl])\n"
"def test_sparse_tensor():\n"
"    # ...（某些测试需要稀疏特征，而这是 OpenGL 所不支持的）"

#: ../../write_test.rst:236
msgid ""
"You may also use the ``extensions`` keyword to exclude backends without "
"specific feature:"
msgstr "你也可以使用 ``extensions`` 关键字来排除没有特定功能的后端："

#: ../../write_test.rst:238
msgid ""
"# Run this test on all backends except for OpenGL\n"
"@ti.test(extensions=[ti.extension.sparse])\n"
"def test_sparse_tensor():\n"
"    # ... (some tests that requires sparse feature which is not supported by "
"OpenGL)"
msgstr ""
"# 在除OpenGL之外的所有后端上运行此测试 \n"
"@ti.test(extensions=[ti.extension.sparse])\n"
"def test_sparse_tensor():\n"
"    # ...（某些测试需要稀疏特征，而这是 OpenGL 所不支持的)"
