# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Yuanming Hu
# This file is distributed under the same license as the taichi package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: taichi 0.5.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-02 22:06+0800\n"
"PO-Revision-Date: 2020-06-14 21:20+0800\n"
"Last-Translator: rexwangcc\n"
"Language: zh_CN\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../type.rst:2
msgid "Type system"
msgstr "类型系统"

#: ../../type.rst:4
msgid ""
"Taichi supports common numerical data types. Each type is denoted as a "
"character indicating its *category* and a number of *precision bits*, "
"e.g., ``i32`` and ``f64``."
msgstr ""

#: ../../type.rst:7
msgid "The *category* can be one of:"
msgstr ""

#: ../../type.rst:9
msgid "``i`` for signed integers, e.g. 233, -666"
msgstr ""

#: ../../type.rst:10
msgid "``u`` for unsigned integers, e.g. 233, 666"
msgstr ""

#: ../../type.rst:11
msgid "``f`` for floating point numbers, e.g. 2.33, 1e-4"
msgstr ""

#: ../../type.rst:13
msgid "The *digital number* can be one of:"
msgstr ""

#: ../../type.rst:15
msgid "``8``"
msgstr ""

#: ../../type.rst:16
msgid "``16``"
msgstr ""

#: ../../type.rst:17
msgid "``32``"
msgstr ""

#: ../../type.rst:18
msgid "``64``"
msgstr ""

#: ../../type.rst:20
msgid ""
"It represents how many **bits** are used in storing the data. The larger "
"the bit number, the higher the precision is."
msgstr ""

#: ../../type.rst:23
msgid "For example, the two most commonly used types:"
msgstr ""

#: ../../type.rst:25
msgid "``i32`` represents a 32-bit signed integer."
msgstr ""

#: ../../type.rst:26
msgid "``f32`` represents a 32-bit floating pointer number."
msgstr ""

#: ../../type.rst:29
msgid "Supported types"
msgstr "支持的类型"

#: ../../type.rst:31
msgid "Currently, supported basic types in Taichi are"
msgstr "目前，Taichi支持的基本类型有"

#: ../../type.rst:33
msgid "int8 ``ti.i8``"
msgstr "int8 ``ti.i8``"

#: ../../type.rst:34
msgid "int16 ``ti.i16``"
msgstr "int16 ``ti.i16``"

#: ../../type.rst:35
msgid "int32 ``ti.i32``"
msgstr "int32 ``ti.i32``"

#: ../../type.rst:36
msgid "int64 ``ti.i64``"
msgstr "int64 ``ti.i64``"

#: ../../type.rst:37
msgid "uint8 ``ti.u8``"
msgstr "uint8 ``ti.u8``"

#: ../../type.rst:38
msgid "uint16 ``ti.u16``"
msgstr "uint16 ``ti.u16``"

#: ../../type.rst:39
msgid "uint32 ``ti.u32``"
msgstr "uint32 ``ti.u32``"

#: ../../type.rst:40
msgid "uint64 ``ti.u64``"
msgstr "uint64 ``ti.u64``"

#: ../../type.rst:41
msgid "float32 ``ti.f32``"
msgstr "float32 ``ti.f32``"

#: ../../type.rst:42
msgid "float64 ``ti.f64``"
msgstr "float64 ``ti.f64``"

#: ../../type.rst:45
msgid "Supported types on each backend:"
msgstr "每种后端支持的类型分别有："

#: ../../type.rst:48
msgid "type"
msgstr "类型"

#: ../../type.rst:48
msgid "CPU/CUDA"
msgstr "CPU/CUDA"

#: ../../type.rst:48
msgid "OpenGL"
msgstr "OpenGL"

#: ../../type.rst:48
msgid "Metal"
msgstr "Metal"

#: ../../type.rst:50
msgid "i8"
msgstr "i8"

#: ../../type.rst:50 ../../type.rst:52 ../../type.rst:54 ../../type.rst:56
#: ../../type.rst:58 ../../type.rst:60 ../../type.rst:62 ../../type.rst:64
#: ../../type.rst:66 ../../type.rst:68
msgid "OK"
msgstr "OK"

#: ../../type.rst:50 ../../type.rst:52 ../../type.rst:56 ../../type.rst:58
#: ../../type.rst:60 ../../type.rst:62 ../../type.rst:64 ../../type.rst:68
msgid "N/A"
msgstr "N/A"

#: ../../type.rst:52
msgid "i16"
msgstr "i16"

#: ../../type.rst:54
msgid "i32"
msgstr "i32"

#: ../../type.rst:56
msgid "i64"
msgstr "i64"

#: ../../type.rst:56
msgid "EXT"
msgstr "EXT"

#: ../../type.rst:58
msgid "u8"
msgstr "u8"

#: ../../type.rst:60
msgid "u16"
msgstr "u16"

#: ../../type.rst:62
msgid "u32"
msgstr "u32"

#: ../../type.rst:64
msgid "u64"
msgstr "u64"

#: ../../type.rst:66
msgid "f32"
msgstr "f32"

#: ../../type.rst:68
msgid "f64"
msgstr "f64"

#: ../../type.rst:71
msgid "(OK: supported, EXT: require extension, N/A: not available)"
msgstr "（OK：已支持，EXT：需要扩展支持，N/A：目前不支持）"

#: ../../type.rst:76
#, fuzzy
msgid "Boolean types are represented using ``ti.i32``."
msgstr "布尔类型应该使用 ``ti.i32`` 来表示。"

#: ../../type.rst:81
msgid "Type promotion"
msgstr ""

#: ../../type.rst:83
#, fuzzy
msgid ""
"Binary operations on different types will give you a promoted type, "
"following the C programming language convention, e.g.:"
msgstr "不同类型的二进制运算像你提供提升的类型，遵循C编程语言，例如。"

#: ../../type.rst:85
msgid "``i32 + f32 = f32`` (integer + float = float)"
msgstr ""

#: ../../type.rst:86
msgid "``i32 + i64 = i64`` (less-bits + more-bits = more-bits)"
msgstr ""

#: ../../type.rst:88
msgid ""
"Basically it will try to choose the more precise type to contain the "
"result value."
msgstr ""

#: ../../type.rst:94
msgid "Default precisions"
msgstr "默认精度"

#: ../../type.rst:96
#, fuzzy
msgid ""
"By default, all numerical literals have 32-bit precisions. For example, "
"``42`` has type ``ti.i32`` and ``3.14`` has type ``ti.f32``."
msgstr ""
"默认情况下，数字文字具有32位精度。 例如，``42`` 的类型为 ``ti.i32`` ， ``3.14`` 的类型为 ``ti.f32`` 。"
" 初始化Taichi时，可以指定默认的整数和浮点精度（ ``default_ip`` 和 ``default_f`` ）："

#: ../../type.rst:99
#, fuzzy
msgid ""
"Default integer and float-point precisions (``default_ip`` and "
"``default_fp``) can be specified when initializing Taichi:"
msgstr ""
"默认情况下，数字文字具有32位精度。 例如，``42`` 的类型为 ``ti.i32`` ， ``3.14`` 的类型为 ``ti.f32`` 。"
" 初始化Taichi时，可以指定默认的整数和浮点精度（ ``default_ip`` 和 ``default_f`` ）："

#: ../../type.rst:101
#, fuzzy
msgid ""
"ti.init(default_fp=ti.f32)\n"
"ti.init(default_fp=ti.f64)\n"
"\n"
"ti.init(default_ip=ti.i32)\n"
"ti.init(default_ip=ti.i64)"
msgstr ""
"ti.init(..., default_fp=ti.f32)\n"
"ti.init(..., default_fp=ti.f64)\n"
"\n"
"ti.init(..., default_ip=ti.i32)\n"
"ti.init(..., default_ip=ti.i64)"

#: ../../type.rst:110
msgid ""
"Also note that you may use ``float`` or ``int`` in type definitions as "
"aliases for default precisions, e.g.:"
msgstr ""

#: ../../type.rst:113
msgid ""
"ti.init(default_ip=ti.i64, default_fp=ti.f32)\n"
"\n"
"x = ti.var(float, 5)\n"
"y = ti.var(int, 5)\n"
"# is equivalent to:\n"
"x = ti.var(ti.f32, 5)\n"
"y = ti.var(ti.i64, 5)\n"
"\n"
"def func(a: float) -> int:\n"
"    ...\n"
"\n"
"# is equivalent to:\n"
"def func(a: ti.f32) -> ti.i64:\n"
"    ..."
msgstr ""

#: ../../type.rst:133
msgid "Type casts"
msgstr "类型转换"

#: ../../type.rst:136
msgid "Implicit casts"
msgstr ""

#: ../../type.rst:140
msgid "The type of a variable is **determinated on it's initialization**."
msgstr ""

#: ../../type.rst:142
msgid ""
"When a *low-precision* variable is assigned to a *high-precision* "
"variable, it will be implicitly promoted to the *wide* type and no "
"warning will be raised:"
msgstr ""

#: ../../type.rst:145
msgid ""
"a = 1.7\n"
"a = 1\n"
"print(a)  # 1.0"
msgstr ""

#: ../../type.rst:151
msgid ""
"When a *high-precision* variable is assigned to a *low-precision* type, "
"it will be implicitly down-cast into the *low-precision* type and Taichi "
"will raise a warning:"
msgstr ""

#: ../../type.rst:154
msgid ""
"a = 1\n"
"a = 1.7\n"
"print(a)  # 1"
msgstr ""

#: ../../type.rst:161
msgid "Explicit casts"
msgstr ""

#: ../../type.rst:163
#, fuzzy
msgid ""
"You may use ``ti.cast`` to explicitly cast scalar values between "
"different types:"
msgstr "使用 ``ti.cast`` 来转换标量值。"

#: ../../type.rst:165
msgid ""
"a = 1.7\n"
"b = ti.cast(a, ti.i32)  # 1\n"
"c = ti.cast(b, ti.f32)  # 1.0"
msgstr ""

#: ../../type.rst:171
msgid ""
"Equivalently, use ``int()`` and ``float()`` to convert values to float-"
"point or integer types of default precisions:"
msgstr ""

#: ../../type.rst:174
msgid ""
"a = 1.7\n"
"b = int(a)    # 1\n"
"c = float(a)  # 1.0"
msgstr ""

#: ../../type.rst:181
msgid "Casting vectors and matrices"
msgstr ""

#: ../../type.rst:183
msgid "Type casts applied to vectors/matrices are element-wise:"
msgstr ""

#: ../../type.rst:185
msgid ""
"u = ti.Vector([2.3, 4.7])\n"
"v = int(u)              # ti.Vector([2, 4])\n"
"# If you are using ti.i32 as default_ip, this is equivalent to:\n"
"v = ti.cast(u, ti.i32)  # ti.Vector([2, 4])"
msgstr ""

#: ../../type.rst:193
msgid "Bit casting"
msgstr ""

#: ../../type.rst:195
msgid ""
"Use ``ti.bit_cast`` to bit-cast a value into another data type. The "
"underlying bits will be preserved in this cast. The new type must have "
"the same width as the the old type. For example, bit-casting ``i32`` to "
"``f64`` is not allowed. Use this operation with caution."
msgstr ""
"使用 ``ti.bit_cast`` 将值比特转换为另一种数据类型。 基础位将保留在此转换中。 新类型的宽度必须与旧类型的宽度相同。 "
"例如，不允许将 ``i32`` 转换成 ``f64``。 请谨慎使用此操作。"

#: ../../type.rst:199
msgid ""
"For people from C++, ``ti.bit_cast`` is equivalent to "
"``reinterpret_cast``."
msgstr ""

#~ msgid "``i32 + f32 = f32``"
#~ msgstr "``i32 + f32 = f32``"

#~ msgid "``f32 + f64 = f64``"
#~ msgstr "``f32 + f64 = f64``"

#~ msgid "``i32 + i64 = i64``"
#~ msgstr "``i32 + i64 = i64``"

#~ msgid ""
#~ "a = 1.4\n"
#~ "b = ti.cast(a, ti.i32)\n"
#~ "c = ti.cast(b, ti.f32)\n"
#~ "\n"
#~ "# Equivalently, use ``int()`` and ``float()``\n"
#~ "# to convert values to default float-point/integer types\n"
#~ "b = int(a)\n"
#~ "c = float(b)\n"
#~ "\n"
#~ "# Element-wise casts in matrices\n"
#~ "mat = ti.Matrix([[3.0, 0.0], [0.3, 0.1]])\n"
#~ "mat_int = mat.cast(int)\n"
#~ "mat_int2 = mat.cast(ti.i32)"
#~ msgstr ""
#~ "a = 1.4\n"
#~ "b = ti.cast(a, ti.i32)\n"
#~ "c = ti.cast(b, ti.f32)\n"
#~ "\n"
#~ "# 等效地，使用 ``int()`` 和 ``float()``\n"
#~ "# 将值转换为默认浮点/整数类型\n"
#~ "b = int(a)\n"
#~ "c = float(b)\n"
#~ "\n"
#~ "# 矩阵中的逐元素转换\n"
#~ "mat = ti.Matrix([[3.0, 0.0], [0.3, 0.1]])\n"
#~ "mat_int = mat.cast(int)\n"
#~ "mat_int2 = mat.cast(ti.i32)"

