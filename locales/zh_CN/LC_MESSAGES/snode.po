# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Taichi Developers
# This file is distributed under the same license as the taichi package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: taichi 0.6.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-02 22:06+0800\n"
"PO-Revision-Date: 2020-08-13 10:20+0800\n"
"Last-Translator: \n"
"Language: zh_CN\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"X-Generator: Poedit 2.3.1\n"

#: ../../snode.rst:4
msgid "Structural nodes (SNodes)"
msgstr "结构节点 (SNodes)"

#: ../../snode.rst:6
msgid ""
"After writing the computation code, the user needs to specify the "
"internal data structure hierarchy. Specifying a data structure includes "
"choices at both the macro level, dictating how the data structure "
"components nest with each other and the way they represent sparsity, and "
"the micro level, dictating how data are grouped together (e.g. structure "
"of arrays vs. array of structures). Taichi provides *Structural Nodes "
"(SNodes)* to compose the hierarchy and particular properties. These "
"constructs and their semantics are listed below:"
msgstr ""
"在编写计算部分的代码之后，用户需要设定内部层次数据结构。包括微观和宏观两"
"部分，宏观上设定层级数据结构组件之间的嵌套关系以及表示稀疏性的方式；微观"
"上，描述数据如何分组(例如，SOA 或 AOS)。Taichi 提供了 *结构节点 "
"(SNodes)* 以满足不同层级数据结构构建时的需求。其结构和语义具体如下所示："

#: ../../snode.rst:9
msgid "dense: A fixed-length contiguous array."
msgstr "稠密集合(dense)：固定长度的连续数组。"

#: ../../snode.rst:11
msgid ""
"bitmasked: This is similar to dense, but it also uses a mask to maintain "
"sparsity information, one bit per child."
msgstr ""
"位掩码集合(bitmasked)：类似于稠密集合，但实现了通过掩码保持数据的稀疏信"
"息。比如为稠密集合的元素分配掩码来记录稀疏信息。"

#: ../../snode.rst:13
msgid ""
"pointer: Store pointers instead of the whole structure to save memory "
"and maintain sparsity."
msgstr ""
"指针集合(pointer)：存储指针而不是整个结构，以节省内存和保持稀疏性。"

#: ../../snode.rst:15
msgid ""
"dynamic: Variable-length array, with a predefined maximum length. It "
"serves the role of ``std::vector`` in C++ or ``list`` in Python, and can "
"be used to maintain objects (e.g. particles) contained in a block."
msgstr ""
"动态集合(dynamic)：可变长度数组，具有预定义的最大长度。它扮演着 C++ 中的 "
"``std::vector`` 或者是 Python 中的 ``list`` 这样的角色，可以用来维护包含"
"在一个块(block)中的对象（例如粒子）。"

#: ../../snode.rst:18
msgid ""
"See :ref:`layout` for more details. ``ti.root`` is the root node of the "
"data structure."
msgstr ""
"你可以在 :ref:`layout` 章节中了解更多详细信息。 ``ti.root`` 是层级数据结"
"构的根结点."

#: ../../snode.rst
msgid "Parameters"
msgstr "参数"

#: ../../snode.rst:22
msgid "(SNode) where to place"
msgstr "(结构节点) 放置(place)操作的目标"

#: ../../snode.rst:23
msgid "(tensor) tensor(s) to be placed"
msgstr "(张量) 要放置的张量对象"

#: ../../snode.rst
msgid "Returns"
msgstr "返回"

#: ../../snode.rst:24
msgid "(SNode) the ``snode`` itself"
msgstr "(结构节点) ``snode`` 对象"

#: ../../snode.rst:26
msgid "The following code places two 0-D tensors named ``x`` and ``y``:"
msgstr "以下示例代码放置了 ``x`` 和 ``y`` 两个零维张量:"

#: ../../snode.rst:30
msgid ""
"x = ti.var(dt=ti.i32)\n"
"y = ti.var(dt=ti.f32)\n"
"ti.root.place(x, y)\n"
"assert x.snode() == y.snode()"
msgstr ""

#: ../../snode.rst:38 ../../snode.rst:53
msgid "(Tensor)"
msgstr "（张量）"

#: ../../snode.rst:39
msgid "(tuple of integers) the shape of tensor"
msgstr "(整数元组) 张量的形状"

#: ../../snode.rst:41
msgid "Equivalent to ``tensor.snode().shape``."
msgstr "相当于 ``tensor.snode().shape``。"

#: ../../snode.rst:43
msgid "For example,"
msgstr "例如,"

#: ../../snode.rst:47
msgid ""
"ti.root.dense(ti.ijk, (3, 5, 4)).place(x)\n"
"x.shape # returns (3, 5, 4)"
msgstr ""
"ti.root.dense(ti.ijk, (3, 5, 4)).place(x)\n"
"x.shape # 返回 (3, 5, 4)"

#: ../../snode.rst:54
msgid "(SNode) the structual node where ``tensor`` is placed"
msgstr "（结构节点） ``tensor`` 所在的结构节点"

#: ../../snode.rst:58
msgid ""
"x = ti.var(dt=ti.i32)\n"
"y = ti.var(dt=ti.f32)\n"
"ti.root.place(x, y)\n"
"x.snode()"
msgstr ""

#: ../../snode.rst:66 ../../snode.rst:83
msgid "(SNode)"
msgstr "（结构节点）"

#: ../../snode.rst:67
msgid "(tuple) the size of node along that axis"
msgstr "（元组）张量在指定轴上的尺寸"

#: ../../snode.rst:71
msgid ""
"blk1 = ti.root\n"
"blk2 = blk1.dense(ti.i,  3)\n"
"blk3 = blk2.dense(ti.jk, (5, 2))\n"
"blk4 = blk3.dense(ti.k,  2)\n"
"blk1.shape  # ()\n"
"blk2.shape  # (3, )\n"
"blk3.shape  # (3, 5, 2)\n"
"blk4.shape  # (3, 5, 4)"
msgstr ""

#: ../../snode.rst:84
msgid ""
"(optional, scalar) the number of steps, i.e. ``n=1`` for parent, ``n=2`` "
"grandparent, etc."
msgstr ""
"（可选, 标量） 向上索引父节点的步数，例如 ``n=1`` 代指父级节点, ``n=2`` "
"代指祖父级节点等等。"

#: ../../snode.rst:85
msgid "(SNode) the parent node of ``snode``"
msgstr "（结构节点） ``snode`` 的父类节点"

#: ../../snode.rst:89
msgid ""
"blk1 = ti.root.dense(ti.i, 8)\n"
"blk2 = blk1.dense(ti.j, 4)\n"
"blk3 = blk2.bitmasked(ti.k, 6)\n"
"blk1.parent()  # ti.root\n"
"blk2.parent()  # blk1\n"
"blk3.parent()  # blk2\n"
"blk3.parent(1) # blk2\n"
"blk3.parent(2) # blk1\n"
"blk3.parent(3) # ti.root\n"
"blk3.parent(4) # None"
msgstr ""

#: ../../snode.rst:102
msgid "Node types"
msgstr "不同类型的节点"

#: ../../snode.rst:107 ../../snode.rst:144
msgid "(SNode) parent node where the child is derived from"
msgstr "（结构节点） 父节点，返回的子节点从该节点派生"

#: ../../snode.rst:108
msgid "(Index or Indices) indices used for this node"
msgstr "（索引）用于子节点上的索引"

#: ../../snode.rst:109
msgid "(scalar or tuple) shape the tensor of vectors"
msgstr "（标量或元组）指定向量张量(tensor of vector)的形状"

#: ../../snode.rst:110 ../../snode.rst:148
msgid "(SNode) the derived child node"
msgstr "（结构节点）派生出来的子节点"

#: ../../snode.rst:112
msgid "The following code places a 1-D tensor of size ``3``:"
msgstr "以下示例代码放置了尺寸为 ``3`` 的一维张量："

#: ../../snode.rst:116
msgid ""
"x = ti.var(dt=ti.i32)\n"
"ti.root.dense(ti.i, 3).place(x)"
msgstr ""

#: ../../snode.rst:119
msgid "The following code places a 2-D tensor of shape ``(3, 4)``:"
msgstr "以下示例代码放置了尺寸为 ``(3,4)`` 的二维张量："

#: ../../snode.rst:123
msgid ""
"x = ti.var(dt=ti.i32)\n"
"ti.root.dense(ti.ij, (3, 4)).place(x)"
msgstr ""

#: ../../snode.rst:128
msgid ""
"If ``shape`` is a scalar and there are multiple indices, then ``shape`` "
"will be automatically expanded to fit the number of indices. For example,"
msgstr ""
"如果给定的 ``shape`` 是一个标量，却又对应了多个索引，那么 ``shape`` 将自"
"动扩充直至和索引数量相等。例如,"

#: ../../snode.rst:133
msgid "snode.dense(ti.ijk, 3)"
msgstr ""

#: ../../snode.rst:135
msgid "is equivalent to"
msgstr "相当于"

#: ../../snode.rst:139
msgid "snode.dense(ti.ijk, (3, 3, 3))"
msgstr ""

#: ../../snode.rst:145
msgid "(Index) the ``dynamic`` node indices"
msgstr "（索引） 动态集合节点(dynamic node)的索引"

#: ../../snode.rst:146
msgid "(scalar) the maximum size of the dynamic node"
msgstr "（标量）描述该动态集合节点的最大尺寸"

#: ../../snode.rst:147
msgid ""
"(optional, scalar) the number of elements in each dynamic memory "
"allocation chunk"
msgstr "（可选标量）描述动态内存分配时块(chunk)中存储的元素数目"

#: ../../snode.rst:150
msgid ""
"``dynamic`` nodes acts like ``std::vector`` in C++ or ``list`` in "
"Python. Taichi's dynamic memory allocation system allocates its memory "
"on the fly."
msgstr ""
"``动态集合`` 节点就像 C++ 中的 ``std::vector`` 或者是 Python 中的 "
"``list`` 。Taichi 具有的动态内存分配系统可以实现自由的分配内存。"

#: ../../snode.rst:153
msgid "The following places a 1-D dynamic tensor of maximum size ``16``:"
msgstr "以下示例代码放置了最大尺寸为 ``16`` 的一维动态张量："

#: ../../snode.rst:157
msgid "ti.root.dynamic(ti.i, 16).place(x)"
msgstr ""

#: ../../snode.rst:165
msgid "TODO: add descriptions here"
msgstr ""

#: ../../snode.rst:170
msgid "Working with ``dynamic`` SNodes"
msgstr "动态集合节点的使用"

#: ../../snode.rst:174 ../../snode.rst:181
msgid "(SNode, dynamic)"
msgstr "（动态集合节点）"

#: ../../snode.rst:175 ../../snode.rst:182
msgid "(scalar or tuple of scalars) the ``dynamic`` node indices"
msgstr "(标量或元组中标量)  ``动态集合`` 节点的索引"

#: ../../snode.rst:176
msgid "(int32) the current size of the dynamic node"
msgstr "（int32）当前动态集合节点的尺寸"

#: ../../snode.rst:183
msgid "(depends on SNode data type) value to store"
msgstr "（取决于结构节点的数据类型）想要储存的值"

#: ../../snode.rst:184
msgid "(int32) the size of the dynamic node, before appending"
msgstr "(int32) 进行附加操作之前的动态节点尺寸"

#: ../../snode.rst:186
msgid "Inserts ``val`` into the ``dynamic`` node with indices ``indices``."
msgstr ""
"使用上述函数，就能实现通过 ``索引(indices)`` 将 ``常量(val)`` 插入到 ``动"
"态集合`` 节点中。"

#: ../../snode.rst:190
msgid "Taichi tensors like powers of two"
msgstr "Taichi 的张量尺寸"

#: ../../snode.rst:192
msgid ""
"Non-power-of-two tensor dimensions are promoted into powers of two and "
"thus these tensors will occupy more virtual address space. For example, "
"a (dense) tensor of size ``(18, 65)`` will be materialized as ``(32, "
"128)``."
msgstr ""
"对于张量，非整二次幂的那些维度会被扩充为整二次幂，因而会占据更多虚拟地址"
"空间。例如，一个 ``(18, 65)`` 的稠密张量在实际存储时相当于一个 ``(32, "
"128)`` 大小的张量。"

#: ../../snode.rst:197
msgid "Indices"
msgstr "索引"

#: ../../snode.rst:212
msgid "(TODO)"
msgstr ""

#~ msgid "axis (0 for ``i`` and 1 for ``j``)"
#~ msgstr "指定轴（0 表示 ``i`` ，1 表示 ``j`` ）"

#~ msgid "(scalar) the dimensionality of the tensor"
#~ msgstr "（标量）张量的维度"

#~ msgid "Equivalent to ``len(tensor.shape())``."
#~ msgstr "相当于 ``len(tensor.shape())`` 。"
